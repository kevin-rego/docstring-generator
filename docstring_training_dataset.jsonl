{"input_text": "Generate docstring for\ndef train(train_dir, model_save_path=None, n_neighbors=None, knn_algo='ball_tree', verbose=False): X = [] y = [] # Loop through each person in the training set for class_dir in os.listdir(train_dir): if not os.path.isdir(os.path.join(train_dir, class_dir)): continue # Loop through each training image for the current person for img_path in image_files_in_folder(os.path.join(train_dir, class_dir)): image = face_recognition.load_image_file(img_path) face_bounding_boxes = face_recognition.face_locations(image) if len(face_bounding_boxes) != 1: # If there are no people (or too many people) in a training image, skip the image. if verbose: print(\"Image {} not suitable for training: {}\".format(img_path, \"Didn't find a face\" if len(face_bounding_boxes) < 1 else \"Found more than one face\")) else: # Add face encoding for current image to the training set X.append(face_recognition.face_encodings(image, known_face_locations=face_bounding_boxes)[0]) y.append(class_dir) # Determine how many neighbors to use for weighting in the KNN classifier if n_neighbors is None: n_neighbors = int(round(math.sqrt(len(X)))) if verbose: print(\"Chose n_neighbors automatically:\", n_neighbors) # Create and train the KNN classifier knn_clf = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, algorithm=knn_algo, weights='distance') knn_clf.fit(X, y) # Save the trained KNN classifier if model_save_path is not None: with open(model_save_path, 'wb') as f: pickle.dump(knn_clf, f) return knn_clf\n", "output_text": "\"\"\"Trains a KNN classifier to recognize faces. Args: train_dir: The directory containing the training images. model_save_path: The path to save the trained model to. If `None`, the model will not be saved. n_neighbors: The number of neighbors to use for weighting in the KNN classifier. If `None`, the number of neighbors will be chosen automatically. knn_algo: The algorithm to use for the KNN classifier. Valid values are `ball_tree` and `kd_tree`. verbose: Whether to print progress messages. Returns: A trained KNN classifier. \"\"\""}
{"input_text": "generate docstring for def calculate_present_value(cashflows, discount_rate): \u00a0\u00a0return np.sum(cashflows / ((1 + discount_rate) ** np.arange(1, len(cashflows) + 1)))", "output_text": "\"\"\"Calculates the present value of a series of cashflows. Args: cashflows: A list of cashflows, where each cashflow is a float. discount_rate: A float representing the discount rate. Returns: A float representing the present value of the cashflows. \"\"\""}
{"input_text": "generate docstring for def calculate_option_price(S, K, T, r, sigma):\n    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    option_price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n    return option_price", "output_text": "\"\"\"Calculate the Black-Scholes price of a European call option. Args: S (float): Current stock price K (float): Strike price T (float): Time to maturity in years r (float): Annual risk-free rate sigma (float): Volatility of stock price Returns: float: Call option price \"\"\""}
{"input_text": "generate docstring for def calculate_portfolio_variance(weights, cov_matrix): \u00a0\u00a0portfolio_variance = np.dot(weights, np.dot(cov_matrix, weights)) \u00a0\u00a0return portfolio_variance", "output_text": "\"\"\"Calculates the portfolio variance. Args: weights: A NumPy array of weights for each asset in the portfolio. cov_matrix: A NumPy array of the covariance matrix for the assets in the portfolio. Returns: A float representing the portfolio variance. \"\"\""}
{"input_text": "generate docstring for def calculate_present_value(cashflows, discount_rate):\n    return np.sum(cashflows / ((1 + discount_rate) ** np.arange(1, len(cashflows) + 1)))", "output_text": "\"\"\"Calculate the present value of a series of cash flows.\r\n\r\nArgs:\r\n    cashflows: List of cash flows over time.\r\n    discount_rate: The discount rate to use.\r\n\r\nReturns:\r\n    The present value of the cash flows.\r\n\"\"\""}
{"input_text": "generate docstring for def calculate_portfolio_variance(weights, cov_matrix):\n    portfolio_variance = np.dot(weights, np.dot(cov_matrix, weights))\n    return portfolio_variance", "output_text": "\"\"\"Calculate the variance of a portfolio. \r\n\r\nArgs:\r\n    weights: List of portfolio weights.\r\n    cov_matrix: Covariance matrix of asset returns.\r\n    \r\nReturns:\r\n    The portfolio variance.\r\n\"\"\""}
{"input_text": "generate docstring for def calculate_option_price(S, K, T, r, sigma):\n    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    option_price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n    return option_price", "output_text": "\"\"\"Calculate the price of a European call option using the Black-Scholes model.\r\n\r\nArgs:\r\n    S: Current stock price.\r\n    K: Strike price of the option.\r\n    T: Time to expiration in years.\r\n    r: Annual risk-free rate. \r\n    sigma: Volatility of stock price.\r\n    \r\nReturns:\r\n    The option price.\r\n\"\"\""}
{"input_text": "generate docstring for def nearestPD(A):\n    B = (A + A.T) / 2\n    _, s, V = la.svd(B)\n    H = np.dot(V.T, np.dot(np.diag(s), V))\n    A2 = (B + H) / 2\n    A3 = (A2 + A2.T) / 2\n    if isPD(A3):\n        return A3\n    spacing = np.spacing(la.norm(A))\n    I = np.eye(A.shape[0]) \n    k = 1\n    while not isPD(A3):\n        mineig = np.min(np.real(la.eigvals(A3)))\n        A3 += I * (-mineig * k**2 + spacing)\n        k += 1\n    return A3", "output_text": "\"\"\"Find the nearest positive-definite matrix to input.\r\n\r\nArgs:\r\n    A: Input matrix.\r\n\r\nReturns:\r\n    Nearest positive-definite matrix.\r\n\"\"\""}
{"input_text": "generate docstring for def isPD(B):\n    try:\n        _ = la.cholesky(B)\n        return True\n    except la.LinAlgError:\n        return False", "output_text": "\"\"\"Returns true when input is positive-definite, via Cholesky.\r\n\r\nArgs:\r\n    B: Input matrix.\r\n    \r\nReturns:\r\n    True if B is positive-definite, False otherwise.\r\n\"\"\""}
{"input_text": "generate docstring for def sample_cov(r, **kwargs):\n    return r.cov()", "output_text": "\"\"\"Returns the sample covariance of the supplied returns.\r\n\r\nArgs:\r\n    r: Asset returns.\r\n    \r\nReturns:\r\n    Sample covariance matrix.\r\n\"\"\""}
{"input_text": "generate docstring for def weight_gmv(r, cov_estimator=sample_cov, **kwargs):\n    est_cov = cov_estimator(r, **kwargs)\n    return gmv(est_cov)", "output_text": "\"\"\"Produces weights for GMV portfolio given a covariance matrix of asset returns.\r\n\r\nArgs:\r\n    r: Asset returns.\r\n    cov_estimator: Function to estimate covariance matrix from returns.\r\n    \r\nReturns:\r\n    Optimal GMV portfolio weights.\r\n\"\"\""}
{"input_text": "generate docstring for def cc_cov(r, **kwargs):\n    rhos = r.corr()\n    n = rhos.shape[0]\n    rho_bar = (rhos.values.sum()-n)/(n*(n-1))\n    ccor = np.full_like(rhos, rho_bar)\n    np.fill_diagonal(ccor, 1.)\n    sd = r.std()\n    return pd.DataFrame(ccor * np.outer(sd, sd), index=r.columns, columns=r.columns)", "output_text": "\"\"\"Estimates a covariance matrix using the Constant Correlation model.\r\n\r\nArgs:\r\n    r: Asset returns.\r\n    \r\nReturns:\r\n    Estimated constant correlation covariance matrix.  \r\n\"\"\""}
{"input_text": "generate docstring for def shrinkage_cov(r, delta=0.5, **kwargs):\n    prior = cc_cov(r, **kwargs)\n    sample = sample_cov(r, **kwargs)\n    return delta*prior + (1-delta)*sample", "output_text": "\"\"\"Estimates a covariance matrix shrinking sample covariance toward constant correlation.\r\n\r\nArgs:\r\n    r: Asset returns.\r\n    delta: Shrinkage parameter.\r\n    \r\nReturns:\r\n    Shrunk covariance matrix.\r\n\"\"\""}
{"input_text": "generate docstring for def get_ffme_returns():\n    me_m = pd.read_csv(\"data/Portfolios_Formed_on_ME_monthly_EW.csv\",\n                       header=0, index_col=0, na_values=-99.99)\n    rets = me_m[['Lo 10', 'Hi 10']]\n    rets.columns = ['SmallCap', 'LargeCap']\n    rets = rets/100\n    rets.index = pd.to_datetime(rets.index, format=\"%Y%m\").to_period('M')\n    return rets", "output_text": "\"\"\"Load Fama-French size portfolio returns. \r\n\r\nReturns:\r\n    DataFrame with 10th and 90th percentile size portfolio returns.\r\n\"\"\""}
{"input_text": "generate docstring for def get_fff_returns():\n    rets = pd.read_csv(\"data/F-F_Research_Data_Factors_m.csv\",  \n                       header=0, index_col=0, na_values=-99.99)/100\n    rets.index = pd.to_datetime(rets.index, format=\"%Y%m\").to_period('M')\n    return rets", "output_text": "\"\"\"Load Fama-French research factor returns.\r\n\r\nReturns:\r\n    DataFrame with Fama-French factor returns.\r\n\"\"\""}
{"input_text": "generate docstring for def get_hfi_returns():\n    hfi = pd.read_csv(\"data/edhec-hedgefundindices.csv\",\n                      header=0, index_col=0, parse_dates=True)\n    hfi = hfi/100\n    hfi.index = hfi.index.to_period('M')\n    return hfi", "output_text": "\"\"\"Load and format EDHEC Hedge Fund Index returns.\r\n\r\nReturns:\r\n    DataFrame with formatted hedge fund index returns.\r\n\" \"\""}
{"input_text": "generate docstring for def get_ind_file(filetype, weighting=\"vw\", n_inds=30):\n    if filetype is \"returns\":\n        name = f\"{weighting}_rets\"\n        divisor = 100\n    elif filetype is \"nfirms\":\n        name = \"nfirms\"\n        divisor = 1\n    elif filetype is \"size\":\n        name = \"size\"\n        divisor = 1\n    else:\n        raise ValueError(f\"filetype must be one of: returns, nfirms, size\")\n    ind = pd.read_csv(f\"data/ind{n_inds}_m_{name}.csv\", header=0, index_col=0, na_values=-99.99)/divisor\n    ind.index = pd.to_datetime(ind.index, format=\"%Y%m\").to_period('M')\n    ind.columns = ind.columns.str.strip()\n    return ind", "output_text": "\"\"\"Load and format Ken French industry portfolio data.\r\n\r\nArgs:\r\n    filetype: Type of data to load, e.g. returns, nfirms, size.\r\n    weighting: Portfolio weighting scheme, 'ew' or 'vw'. \r\n    n_inds: Number of industry portfolios to load.\r\n    \r\nReturns:\r\n    DataFrame with loaded and formatted data.\r\n\"\"\""}
{"input_text": "generate docstring for def get_ind_returns(weighting=\"vw\", n_inds=30):\n    return get_ind_file(\"returns\", weighting=weighting, n_inds=n_inds)", "output_text": "\"\"\"Load and format Ken French industry portfolio returns.\r\n\r\nArgs:\r\n    weighting: Portfolio weighting scheme, 'ew' or 'vw'.\r\n    n_inds: Number of industry portfolios to load.  \r\n\r\nReturns:\r\n    DataFrame with industry portfolio returns. \r\n\"\"\""}
{"input_text": "generate docstring for def get_ind_nfirms(n_inds=30):\n    return get_ind_file(\"nfirms\", n_inds=n_inds)", "output_text": "\"\"\"Load and format average number of firms in Ken French industry portfolios.\r\n\r\nArgs:\r\n    n_inds: Number of industry portfolios to load.\r\n    \r\nReturns:\r\n    DataFrame with average number of firms.\r\n\"\"\""}
{"input_text": "generate docstring for def get_ind_size(n_inds=30):\n    return get_ind_file(\"size\", n_inds=n_inds)", "output_text": "\"\"\"Load and format average size of Ken French industry portfolios. \r\n\r\nArgs:\r\n    n_inds: Number of industry portfolios to load.\r\n    \r\nReturns:\r\n    DataFrame with average market cap.\r\n\"\"\""}
{"input_text": "generate docstring for def get_ind_market_caps(n_inds=30, weights=False):\n    ind_nfirms = get_ind_nfirms(n_inds=n_inds)\n    ind_size = get_ind_size(n_inds=n_inds)\n    ind_mktcap = ind_nfirms * ind_size\n    if weights:\n        total_mktcap = ind_mktcap.sum(axis=1)\n        ind_capweight = ind_mktcap.divide(total_mktcap, axis=\"rows\")\n        return ind_capweight\n    return ind_mktcap", "output_text": "\"\"\"Derive market cap weights from Ken French industry portfolio data.\r\n\r\nArgs:\r\n    n_inds: Number of industry portfolios. \r\n    weights: If True, return cap weights. Otherwise, total caps.\r\n    \r\nReturns:\r\n    DataFrame with market cap weights or total caps.\r\n\"\"\""}
{"input_text": "generate docstring for def get_total_market_index_returns(n_inds=30):\n    ind_capweight = get_ind_market_caps(n_inds=n_inds)  \n    ind_return = get_ind_returns(weighting=\"vw\", n_inds=n_inds)\n    total_market_return = (ind_capweight * ind_return).sum(axis=\"columns\")\n    return total_market_return", "output_text": "\"\"\"Derive total market cap-weighted index returns from Ken French data. \r\n\r\nArgs:\r\n    n_inds: Number of industry portfolios used.\r\n    \r\nReturns:\r\n    Series with market cap weighted total returns.\r\n\"\"\""}
{"input_text": "generate docstring for def skewness(r):\n    demeaned_r = r - r.mean()\n    sigma_r = r.std(ddof=0)\n    exp = (demeaned_r**3).mean()            \n    return exp/sigma_r**3", "output_text": "\"\"\"Compute skewness of supplied Series or DataFrame.\r\n\r\nArgs:\r\n    r: Returns to compute skewness on.\r\n    \r\nReturns:\r\n    Skewness as float or Series.\r\n\"\"\""}
{"input_text": "generate docstring for def kurtosis(r):\n    demeaned_r = r - r.mean()\n    sigma_r = r.std(ddof=0)\n    exp = (demeaned_r**4).mean()            \n    return exp/sigma_r**4", "output_text": "\"\"\"Compute kurtosis of supplied Series or DataFrame.\r\n\r\nArgs:\r\n    r: Returns to compute kurtosis on.\r\n\r\nReturns:\r\n    Kurtosis as float or Series. \r\n\"\"\""}
{"input_text": "generate docstring for def compound(r):\n    return np.expm1(np.log1p(r).sum())", "output_text": "\"\"\"Compound set of returns.\r\n\r\nArgs:\r\n    r: Returns to compound.\r\n    \r\nReturns:\r\n    Compounded total return.\r\n\"\"\""}
{"input_text": "generate docstring for def annualize_rets(r, periods_per_year):\n    compounded_growth = (1+r).prod()\n    n_periods = r.shape[0]\n    return compounded_growth**(periods_per_year/n_periods)-1", "output_text": "\"\"\"Annualize a set of returns.\r\n\r\nArgs:\r\n    r: Returns to annualize.\r\n    periods_per_year: Periods per year.\r\n    \r\nReturns:\r\n    Annualized returns.\r\n\"\"\""}
{"input_text": "generate docstring for def annualize_vol(r, periods_per_year):\n    return r.std()*(periods_per_year**0.5)", "output_text": "\"\"\"Annualize volatility of a set of returns.\r\n\r\nArgs:\r\n    r: Returns to annualize volatility of.\r\n    periods_per_year: Periods per year.\r\n    \r\nReturns:\r\n    Annualized volatility.\r\n\"\"\""}
{"input_text": "generate docstring for def sharpe_ratio(r, riskfree_rate, periods_per_year):\n    rf_per_period = (1+riskfree_rate)**(1/periods_per_year)-1\n    excess_ret = r - rf_per_period\n    ann_ex_ret = annualize_rets(excess_ret, periods_per_year)\n    ann_vol = annualize_vol(r, periods_per_year)\n    return ann_ex_ret/ann_vol", "output_text": "\"\"\"Compute annualized Sharpe ratio of a set of returns.\r\n\r\nArgs:\r\n    r: Returns.\r\n    risk_free_rate: Annual risk-free rate.  \r\n    periods_per_year: Periods per year.\r\n    \r\nReturns:\r\n    Annualized Sharpe ratio.\r\n\"\"\""}
{"input_text": "generate docstring for def is_normal(r, level=0.01):\n    if isinstance(r, pd.DataFrame):\n        return r.aggregate(is_normal)\n    else:\n        statistic, p_value = scipy.stats.jarque_bera(r)\n        return p_value > level", "output_text": "\"\"\"Perform Jarque-Bera normality test on returns.\r\n\r\nArgs:\r\n    r: Returns to test.\r\n    level: Significance level.\r\n    \r\nReturns:\r\n    True if normal, False otherwise.\r\n\"\"\""}
{"input_text": "generate docstring for def drawdown(return_series: pd.Series):\n    wealth_index = 1000*(1+return_series).cumprod()\n    previous_peaks = wealth_index.cummax()\n    drawdowns = (wealth_index - previous_peaks)/previous_peaks\n    return pd.DataFrame({\"Wealth\": wealth_index,  \n                         \"Previous Peak\": previous_peaks, \n                         \"Drawdown\": drawdowns})", "output_text": "\"\"\"Compute drawdowns from a returns time series.\r\n\r\nArgs:\r\n    return_series: Returns series.\r\n    \r\nReturns:\r\n    DataFrame with columns for wealth index, previous peaks, and drawdowns.\r\n\"\"\""}
{"input_text": "generate docstring for def semideviation(r):\n    if isinstance(r, pd.Series):\n        is_negative = r < 0\n        return r[is_negative].std(ddof=0)\n    elif isinstance(r, pd.DataFrame):\n        return r.aggregate(semideviation)\n    else:\n        raise TypeError(\"Expected r to be a Series or DataFrame\")", "output_text": "\"\"\"Compute semideviation (negative semideviation) of a returns series.\r\n\r\nArgs:\r\n    r: Returns series.   \r\n    \r\nReturns:\r\n    Semideviation as float.\r\n\"\"\""}
{"input_text": "generate docstring for def var_historic(r, level=5):\n    if isinstance(r, pd.DataFrame):\n        return r.aggregate(var_historic, level=level)\n    elif isinstance(r, pd.Series):\n        return -np.percentile(r, level)\n    else:\n        raise TypeError(\"Expected r to be a Series or DataFrame\")", "output_text": "\"\"\"Compute Value at Risk (VaR) from a returns series at given confidence level.\r\n\r\nArgs:\r\n    r: Returns series.\r\n    level: Confidence level, e.g. 95%.\r\n    \r\nReturns:\r\n    VaR as a float.\r\n\"\"\""}
{"input_text": "generate docstring for def cvar_historic(r, level=5):\n    if isinstance(r, pd.Series):\n        is_beyond = r <= -var_historic(r, level=level)\n        return -r[is_beyond].mean() \n    elif isinstance(r, pd.DataFrame):\n        return r.aggregate(cvar_historic, level=level)\n    else:\n        raise TypeError(\"Expected r to be a Series or DataFrame\")", "output_text": "\"\"\"Compute Conditional VaR (CVaR) from a returns series at given confidence level.\r\n\r\nArgs:\r\n    r: Returns series.\r\n    level: Confidence level, e.g. 95%.\r\n\r\nReturns: \r\n    CVaR as a float. \r\n\"\"\""}
{"input_text": "generate docstring for def var_gaussian(r, level=5, modified=False):\n    z = norm.ppf(level/100)  \n    if modified:    \n        s = skewness(r)\n        k = kurtosis(r)\n        z = (z + \n                (z**2 - 1)*s/6 + \n                (z**3 -3*z)*(k-3)/24 -                \n                (2*z**3 - 5*z)*(s**2)/36\n           )\n    return -(r.mean() + z*r.std(ddof=0))", "output_text": "\"\"\"Compute parametric Gaussian VaR from a returns series.\r\n\r\nArgs:  \r\n    r: Returns series.\r\n    level: Confidence level, e.g. 95%.\r\n    modified: Whether to apply Cornish-Fisher modification.\r\n    \r\nReturns:\r\n    Parametric Gaussian VaR as a float. \r\n\"\"\""}
{"input_text": "generate docstring for def portfolio_return(weights, returns):\n    return weights.dot(returns)", "output_text": "\"\"\"Compute portfolio return from a set of weighted constituent returns.\r\n\r\nArgs:\r\n    weights: Portfolio weights.\r\n    returns: Constituent returns.\r\n    \r\nReturns:\r\n    Portfolio return.\r\n\"\"\""}
{"input_text": "generate docstring for def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\n", "output_text": "\"\"\"\n    Sorts an array using the bubble sort algorithm.\n\n    Args:\n        arr (list): List of elements to be sorted.\n\n    Returns:\n        list: Sorted list.\n    \"\"\""}
{"input_text": "generate docstring for def to_lowercase(string):\n    return string.lower()\n", "output_text": "\"\"\"\n    Converts a string to lowercase.\n\n    Args:\n        string (str): String to be converted.\n\n    Returns:\n        str: String in lowercase.\n    \"\"\""}
{"input_text": "generate docstring for def factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\n", "output_text": "\"\"\"\n    Calculates factorial of a number.\n\n    Args:\n        n (int): Number to calculate factorial for.\n\n    Returns:\n        int: Factorial of n.\n    \"\"\""}
{"input_text": "generate docstring for def linear_search(arr, x):\n    for i in range(len(arr)):\n        if arr[i] == x:\n            return i\n    return -1\n", "output_text": "\"\"\"\n    Performs linear search to find an element in a list.\n\n    Args:\n        arr (list): List of elements.\n        x (any): Element to search for.\n\n    Returns:\n        int: Index of the element if found, else -1.\n    \"\"\""}
{"input_text": "generate docstring for \nfunction bubbleSort(arr) {\n    let n = arr.length;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                let temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n    return arr;\n}\n        ", "output_text": "/**\n * Sorts an array using the bubble sort algorithm.\n *\n * @param {Array} arr - The array to be sorted.\n * @returns {Array} - The sorted array.\n */\n        "}
{"input_text": "generate docstring for\nfunction toLowerCase(string) {\n    return string.toLowerCase();\n}\n        ", "output_text": "\n/**\n * Converts a string to lowercase.\n *\n * @param {string} string - The string to be converted.\n * @returns {string} - The string in lowercase.\n */\n        "}
{"input_text": "generate docstring for\nfunction factorial(n) {\n    if (n === 0) {\n        return 1;\n    } else {\n        return n * factorial(n - 1);\n    }\n}\n        ", "output_text": "\n/**\n * Calculates factorial of a number.\n *\n * @param {number} n - The number to calculate factorial for.\n * @returns {number} - The factorial of n.\n */\n        "}
{"input_text": "generate docstring for\nfunction linearSearch(arr, x) {\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] === x) {\n            return i;\n        }\n    }\n    return -1;\n}\n        ", "output_text": "\n/**\n * Performs linear search to find an element in an array.\n *\n * @param {Array} arr - The array of elements.\n * @param {*} x - The element to search for.\n * @returns {number} - The index of the element if found, else -1.\n */\n        "}
{"input_text": "generate docstring for function add(a, b) {\n  return a + b;\n}", "output_text": "/**\n * Adds two numbers together.\n * @param {number} a The first number.\n * @param {number} b The second number.\n * @returns {number} The sum of the two numbers.\n */"}
{"input_text": "generate docstring for function subtract(a, b) {\n  return a - b;\n}", "output_text": "/**\n * Subtracts two numbers.\n * @param {number} a The first number. \n * @param {number} b The number to subtract from a.\n * @returns {number} The result of the subtraction.\n */"}
{"input_text": "generate docstring for function multiply(a, b) {\n  return a * b;\n}", "output_text": "/**\n * Multiplies two numbers together.\n * @param {number} a The first number.\n * @param {number} b The second number.\n * @returns {number} The product of the numbers.\n */"}
{"input_text": "generate docstring for function divide(a, b) {\n  return a / b; \n}", "output_text": "/**\n * Divides two numbers.\n * @param {number} a The dividend. \n * @param {number} b The divisor.\n * @returns {number} The quotient of the division. \n */"}
{"input_text": "generate docstring for function increment(n) {\n  return n + 1;\n}", "output_text": "/**\n * Increments a number by 1.\n * @param {number} n The number to increment.\n * @returns {number} n + 1\n */"}
{"input_text": "generate docstring for function decrement(n) {\n  return n - 1;\n}", "output_text": "/** \n * Decrements a number by 1.\n * @param {number} n The number to decrement.\n * @returns {number} n - 1\n */"}
{"input_text": "generate docstring for function pow(base, exponent) {\n  return base ** exponent;\n}", "output_text": "/**\n * Calculates the exponentiation of a base number raised to a power.\n * @param {number} base The base number. \n * @param {number} exponent The power to raise the base to.\n * @returns {number} base raised to the power exponent.\n */"}
{"input_text": "generate docstring for function square(n) {\n  return n * n;\n}", "output_text": "/**\n * Squares a number by multiplying it by itself.\n * @param {number} n The number to square.\n * @returns {number} n * n\n */"}
{"input_text": "generate docstring for function cube(n) {\n  return n * n * n; \n}", "output_text": "/**\n * Cubes a number by raising it to the 3rd power.\n * @param {number} n The number to cube.\n * @returns {number} n * n * n\n */"}
{"input_text": "generate docstring for function factorial(n) {\n  if (n === 0) return 1;\n  return n * factorial(n - 1);\n}", "output_text": "/**\n * Calculates the factorial of an integer n.\n * @param {number} n The number to take the factorial of.\n * @returns {number} The factorial of n.  \n */"}
{"input_text": "generate docstring for function fibonacci(n) {\n  if (n < 2) return n;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}", "output_text": "/**\n * Calculates the nth Fibonacci number recursively.\n * @param {number} n The index of the Fibonacci number to compute. \n * @returns {number} The nth Fibonacci number.\n */"}
{"input_text": "generate docstring for function isEven(n) {\n  return n % 2 === 0;\n}", "output_text": "/**\n * Checks if a number is even. \n * @param {number} n The number to check.\n * @returns {boolean} True if n is even, false if n is odd.\n */"}
{"input_text": "generate docstring for function isOdd(n) {\n  return Math.abs(n % 2) === 1;\n}", "output_text": "/**\n * Checks if a number is odd.\n * @param {number} n The number to check.\n * @returns {boolean} True if n is odd, false if n is even. \n */  "}
{"input_text": "generate docstring for function isPrime(n) {\n  for(let i = 2; i < n; i++) {\n    if(n % i === 0) return false;\n  }\n  return n > 1;\n}", "output_text": "/**\n * Checks if a number is prime.\n * @param {number} n The number to check.\n * @returns {boolean} True if n is prime, false otherwise.\n */"}
{"input_text": "generate docstring for function reverseString(str) {\n  return str.split('').reverse().join('');\n}", "output_text": "/** \n * Reverses the characters in a string.\n * @param {string} str The string to reverse.\n * @returns {string} The reversed string.\n */"}
{"input_text": "generate docstring for function capitalize(str) {\n  return str[0].toUpperCase() + str.slice(1);\n}", "output_text": "/**\n * Capitalizes the first letter of a string.\n * @param {string} str The input string.\n * @returns {string} The capitalized string.\n */"}
{"input_text": "generate docstring for function upperCase(str) {\n  return str.toUpperCase();\n}", "output_text": "/**\n * Converts a string to upper case. \n * @param {string} str The input string. \n * @returns {string} The upper case string.\n */"}
{"input_text": "generate docstring for function lowerCase(str) {\n  return str.toLowerCase();\n}", "output_text": "/**\n * Converts a string to lower case. \n * @param {string} str The input string.\n * @returns {string} The lower case string. \n */"}
{"input_text": "generate docstring for function repeatString(str, n) {\n  return str.repeat(n);\n}", "output_text": "/**\n * Repeats a string n times.\n * @param {string} str The string to repeat.\n * @param {number} n The number of times to repeat.\n * @returns {string} The repeated string.\n */ "}
{"input_text": "generate docstring for function truncateString(str, n) {\n  return str.slice(0, n);\n}", "output_text": "/**\n * Truncates a string after n characters.\n * @param {string} str The string to truncate.\n * @param {number} n Number of characters where string gets truncated.\n * @returns {string} The truncated string.\n */"}
{"input_text": "generate docstring for function camelCase(str) {\n  \n}", "output_text": "/**\n * Converts a string to camel case.  \n * @param {string} str The input string.\n * @returns {string} The camel cased string.\n */"}
{"input_text": "generate docstring for function reverseArray(arr) {\n  return arr.slice().reverse();\n}", "output_text": "/**\n * Reverses an array in place.\n * @param {Array} arr The array to reverse.\n * @returns {Array} The reversed array.\n */"}
{"input_text": "generate docstring for function shuffleArray(arr) {\n  let i = arr.length;\n  while (i--) {\n    const ri = Math.floor(Math.random() * (i+1));\n    [arr[i], arr[ri]] = [arr[ri], arr[i]];\n  }\n  return arr;  \n}", "output_text": "/** \n * Shuffles an array in place.\n * @param {Array} arr The array to shuffle.\n * @returns {Array} The shuffled array.\n */"}
{"input_text": "generate docstring for function chunkArray(arr, size) {\n  const chunked = [];\n  let i = 0;while (i < arr.length) {\n    chunked.push(arr.slice(i, i + size));\n    i += size;\n  }\"\n\"  return chunked;\n}", "output_text": "/**\n * Splits an array into chunks of size n. \n * @param {Array} arr The array to chunk.\n * @param {number} size The chunk size.\n * @returns {Array} The chunked array.\n */"}
{"input_text": "generate docstring for function compactArray(arr) {\n  return arr.filter(Boolean);\n}", "output_text": "/**\n * Removes falsy values from an array.\n * @param {Array} arr The array to compact.\n * @returns {Array} Array with falsy values removed.\n */"}
{"input_text": "generate docstring for function intersection(a, b) {\n  return a.filter(x => b.includes(x));\n} ", "output_text": "/**\n * Computes the intersection of two arrays.\n * @param {Array} a First array.\n * @param {Array} b Second array.  \n * @returns {Array} Intersection of the two arrays.\n */"}
{"input_text": "generate docstring for function difference(a, b) {\n  return a.filter(x => !b.includes(x));\n}", "output_text": "/** \n * Computes the difference of two arrays.\n * @param {Array} a First array.\n * @param {Array} b Second array.\n * @returns {Array} Values from a not in b. \n */"}
{"input_text": "generate docstring for function union(a, b) {\n  return [...new Set([...a, ...b])];\n}", "output_text": "/**\n * Computes the union of two arrays.\n * @param {Array} a First array \n * @param {Array} b Second array\n * @returns {Array} Unique values from both arrays.\n */"}
{"input_text": "generate docstring for function objectValues(obj) {\n  return Object.values(obj);\n}", "output_text": "/**\n * Gets all object values.\n * @param {Object} obj The object. \n * @returns {Array} The object values.\n */ "}
{"input_text": "generate docstring for function objectKeys(obj) {\n  return Object.keys(obj);\n}", "output_text": "/**\n * Gets all object keys. \n * @param {Object} obj The object.\n * @returns {Array} The object keys.\n */"}
{"input_text": "generate docstring for function pick(obj, keys) {\n  return keys.map(k => k in obj ? {[k]: obj[k]} : {})\n            .reduce((res, o) => Object.assign(res, o), {});\n}", "output_text": "/**\n * Picks properties specified by keys from an object.\n * @param {Object} obj The object to pick from.\n * @param {string[]} keys The keys to pick.\n * @returns {Object} A new object with the picked keys.\n */"}
{"input_text": "generate docstring for function omit(obj, keys) {\n  const copy = {...obj};\n  keys.forEach(k => delete copy[k]);\n  return copy;\n}", "output_text": "/**\n * Omits properties specified by keys from an object.\n * @param {Object} obj The source object.\n * @param {string[]} keys The keys to omit.\n * @returns {Object} A new object without the omitted keys.\n */"}
{"input_text": "generate docstring for function mapValues(obj, fn) {\n  return Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, fn(v)]));\n}", "output_text": "/**\n * Maps values of an object via function.\n * @param {Object} obj The source object. \n * @param {Function} fn Mapping function.\n * @returns {Object} A new object with mapped values.\n */"}
{"input_text": "generate docstring for function deepCopy(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}", "output_text": "/**\n * Deep copies an object.\n * @param {Object} obj The object to copy.\n * @returns {Object} A deep copy of the object.\n */ "}
{"input_text": "generate docstring for function objectEquals(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);  \n}", "output_text": "/**\n * Checks if two objects have the same keys and values.\n * @param {Object} a First object.\n * @param {Object} b Second object.\n * @returns {boolean} True if equal, false otherwise.\n */"}
{"input_text": "generate docstring for function bind(fn, context, ...args) {\n  return fn.bind(context, ...args);\n}", "output_text": "/**\n * Binds a function to a context and arguments.\n * @param {Function} fn The function to bind.\n * @param {Object} context The context to bind to.\n * @param {...*} args Arguments to prepend. \n * @returns {Function} The bound function.\n */"}
{"input_text": "generate docstring for function once(fn) {\n  let done = false;\n  return function(...args) {\n    if (!done) {\n      done = true;\n      fn.apply(this, args);\n    }\n  }\n}", "output_text": "/**\n * Creates a function that can only be called once.\n * @param {Function} fn The function to wrap.\n * @returns {Function} A function that can be called only once.\n */"}
{"input_text": "generate docstring for function after(n, fn) {\n  let counter = 0;\n  return function(...args) {\n    counter++;\n    if (counter === n) fn.apply(this, args);\n  }\n}", "output_text": "/**\n * Creates a function that invokes fn only after n calls.\n * @param {number} n Number of calls before fn is invoked. \n * @param {Function} fn Function to restrict.\n * @returns {Function} Restricted function.\n */"}
{"input_text": "generate docstring for function memoize(fn) {\n  const cache = new Map();\n  return function(...args) {\n    const key = JSON.stringify(args);\n    if (cache.has(key)) return cache.get(key);\n    const res = fn.apply(this, args);\n    cache.set(key, res);\n    return res;\n  }\n}", "output_text": "/**\n * Caches results of a function.\n * @param {Function} fn The function to cache.\n * @returns {Function} Memoized function.\n */"}
{"input_text": "generate docstring for function pipe(...fns) {\n  return function(x) {\n    return fns.reduce((v, fn) => fn(v), x);\n  }\n}", "output_text": "/**\n * Composes functions from right to left.\n * @param {...Function} fns The functions to compose.\n * @returns {Function} Composed function.\n */ "}
{"input_text": "generate docstring for function compose(...fns) {\n  return function(x) {\n    return fns.reduceRight((v, fn) => fn(v), x);\n  }\n}", "output_text": "/** \n * Composes functions from left to right.\n * @param {...Function} fns The functions to compose.\n * @returns {Function} Composed function.\n */"}
{"input_text": "generate docstring for function sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}", "output_text": "/**\n * Resolves after ms milliseconds. \n * @param {number} ms Milliseconds to wait.\n * @returns {Promise} Promise that resolves after ms.\n */"}
{"input_text": "generate docstring for function debounce(fn, ms) {\n  let timeout;\n  return function(...args) {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => fn.apply(this, args), ms);\n  }\n}", "output_text": "/**\n * Creates a debounced function.\n * @param {Function} fn The function to debounce. \n * @param {number} ms The debounce delay in ms.\n * @returns {Function} The debounced function.\n */"}
{"input_text": "generate docstring for function throttle(fn, ms) {\n  let waiting = false;\n  return function(...args) {\n    if (waiting) return;\n    waiting = true;\n    fn.apply(this, args);\n    setTimeout(() => waiting = false, ms);\n  }  \n}", "output_text": "/**\n * Creates a throttled function.\n * @param {Function} fn The function to throttle.\n * @param {number} ms The throttle delay in ms. \n * @returns {Function} Throttled function. \n */"}
{"input_text": "generate docstring for function randomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}", "output_text": "/**\n * Generates a random integer between min and max.\n * @param {number} min The minimum value.\n * @param {number} max The maximum value.\n * @returns {number} Random integer between min and max.\n */"}
{"input_text": "generate docstring for function uuid() {\n  return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>\n    (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)\n  );\n}", "output_text": "/**\n * Generates a UUID.\n * @returns {string} UUID\n */"}
{"input_text": "generate docstring for function logger(namespace) {\n  return function(message) {\n    console.log(`[${namespace}] ${message}`); \n  }\n}", "output_text": "/**\n * Creates a logger function.\n * @param {string} namespace The logging namespace. \n * @returns {Function} Logger function.\n */"}
{"input_text": "generate docstring for function times(n, fn) {\n  Array.from({length: n}, (_, i) => fn(i));\n}", "output_text": "/**\n * Invokes a function n times.\n * @param {number} n Number of invocations.\n * @param {Function} fn Function to invoke.\n */"}
{"input_text": "generate docstring for function requireUncached(module) {\n  delete require.cache[require.resolve(module)];\n  return require(module);  \n}\n", "output_text": "/**\n * Requires a module bypassing the cache. \n * @param {string} module Module to require.\n * @returns Required module.\n */"}
{"input_text": "generate docsting for double sum(std::vector<double> & const values) {\n    ...\n}", "output_text": "/**\n * Sum numbers in a vector.\n *\n * @param values Container whose values are summed.\n * @return sum of `values`, or 0.0 if `values` is empty.\n */"}
{"input_text": "generate docstring for template <typename T, typename ComparatorT = std::less<T>>\nclass LookupTable\n{\n    ...\n}", "output_text": "/**\n * Storage for arbitrary data with log(N) lookup.\n *\n * ...\n *\n * @tparam T the type of data stored in the table\n * @tparam ComparatorT callable defining a strict weak ordering for objects\n *     of type `T`. Its `operator()` must accept two `T` and return `true`\n *     if and only if the first argument comes before the second. It must\n *     not throw exceptions.\n */"}
{"input_text": "generate docstring for protected long edgeCount() { long degreeSum = 0L; for (N node : nodes()) { degreeSum += degree(node); } // According to the degree sum formula, this is equal to twice the number of edges. checkState((degreeSum & 1) == 0); return degreeSum >>> 1; }", "output_text": "/**\n * Returns the number of edges in the graph.\n *\n * This is calculated by summing the degrees of all nodes in the graph, dividing\n * by two, and rounding up. This is because each edge is connected to two nodes.\n *\n * @return The number of edges in the graph.\n */"}
{"input_text": "generate docstring for public static char saturatedCast(long value) { if (value > Character.MAX_VALUE) { return Character.MAX_VALUE; } if (value < Character.MIN_VALUE) { return Character.MIN_VALUE; } return (char) value; }", "output_text": "/**\n * Performs a saturated cast of the given long value to a char.\n *\n * If the value is greater than Character.MAX_VALUE, it is returned.\n * If the value is less than Character.MIN_VALUE, it is returned.\n * Otherwise, the value is cast to a char and returned.\n *\n * @param value The long value to be cast.\n * @return The saturated cast of the given long value to a char.\n */"}
{"input_text": "generate docstring for public static boolean isPowerOfTwo(BigInteger x) { checkNotNull(x); return x.signum() > 0 && x.getLowestSetBit() == x.bitLength() - 1; }\t", "output_text": "/**\n * Returns `true` if the given BigInteger is a power of two, `false` otherwise.\n *\n * A BigInteger is considered a power of two if and only if it is positive and has a single\n * one bit. This can be determined by checking if the lowest set bit of the BigInteger is equal to\n * its bit length minus one.\n *\n * @param x The BigInteger to check.\n * @return `true` if the given BigInteger is a power of two, `false` otherwise.\n */"}
{"input_text": "generate docstring for parseInt", "output_text": "\n/**\n * Parses a string and returns an integer.\n * @param {string} string - The string to parse\n * @param {number} radix - An integer between 2 and 36 that represents the radix (optional)\n * @returns {number} The parsed integer\n */\n"}
{"input_text": "generate docstring for parseFloat", "output_text": "\n/**\n * Parses a string and returns a float.\n * @param {string} string - The string to parse\n * @returns {number} The parsed float\n */\n"}
{"input_text": "generate docstring for isNaN", "output_text": "\n/**\n * Checks if a value is NaN.\n * @param {*} value - The value to check\n * @returns {boolean} True if value is NaN, false otherwise\n */\n"}
{"input_text": "generate docstring for isFinite", "output_text": "\n/**\n * Checks if a value is a finite number.\n * @param {*} value - The value to check\n * @returns {boolean} True if value is finite, false otherwise\n */\n"}
{"input_text": "generate docstring for encodeURI", "output_text": "\n/**\n * Encodes a URI.\n * @param {string} uri - The URI to encode\n * @returns {string} The encoded URI\n */\n"}
{"input_text": "generate docstring for decodeURI", "output_text": "\n/**\n * Decodes a URI.\n * @param {string} encodedURI - The encoded URI to decode\n * @returns {string} The decoded URI\n */\n"}
{"input_text": "generate docstring for encodeURIComponent", "output_text": "\n/**\n * Encodes a URI component.\n * @param {string} uriComponent - The URI component to encode\n * @returns {string} The encoded URI component\n */\n"}
{"input_text": "generate docstring for decodeURIComponent", "output_text": "\n/**\n * Decodes a URI component.\n * @param {string} encodedURIComponent - The encoded URI component to decode\n * @returns {string} The decoded URI component\n */\n"}
{"input_text": "generate docstring for escape", "output_text": "\n/**\n * Escapes a string for use in HTML.\n * @param {string} string - The string to escape\n * @returns {string} The escaped string\n */\n"}
{"input_text": "generate docstring for unescape", "output_text": "\n/**\n * Unescapes an escaped string.\n * @param {string} escapedString - The escaped string to unescape\n * @returns {string} The unescaped string\n */\n"}
{"input_text": "generate docstring for eval", "output_text": "\n/**\n * Evaluates JavaScript code represented as a string.\n * @param {string} code - The code to evaluate\n * @returns {*} The result of evaluating the code\n */\n"}
{"input_text": "generate docstring for isArray", "output_text": "\n/**\n * Checks if a value is an array.\n * @param {*} value - The value to check\n * @returns {boolean} True if value is an array, false otherwise\n */\n"}
{"input_text": "generate docstring for Date", "output_text": "\n/**\n * Creates a Date object.\n * @param {number} year - The year\n * @param {number} month - The month\n * @param {number} day - The day\n * @param {number} hour - The hours\n * @param {number} minutes - The minutes\n * @param {number} seconds - The seconds\n * @param {number} milliseconds - The milliseconds\n * @returns {Date} The created Date object\n */\n"}
{"input_text": "generate docstring for setTimeout", "output_text": "\n/**\n * Sets a timer that executes a function after a specified delay.\n * @param {Function} callback - The function to execute\n * @param {number} delay - The delay in milliseconds\n * @returns {number} The ID of the timer  \n */\n"}
{"input_text": "generate docstring for clearTimeout", "output_text": "\n/**\n * Clears a timer set by setTimeout.\n * @param {number} id - The id of the timer to clear \n */\n"}
{"input_text": "generate docstring for setInterval", "output_text": "\n/**\n * Sets an interval that executes a function repeatedly.\n * @param {Function} callback - The function to execute\n * @param {number} delay - The interval delay in milliseconds\n * @returns {number} The ID of the interval\n */\n"}
{"input_text": "generate docstring for clearInterval", "output_text": "\n/**\n * Clears an interval set by setInterval.\n * @param {number} id - The id of the interval to clear\n */\n"}
{"input_text": "generate docstring for requestAnimationFrame", "output_text": "\n/**\n * Requests the browser to call a function for animating.\n * @param {Function} callback - The function to execute\n * @returns {number} The ID of the request animation frame\n */\n"}
{"input_text": "generate docstring for cancelAnimationFrame", "output_text": "\n/**\n * Cancels an animation frame request.\n * @param {number} id - The id of the request to cancel\n */\n"}
{"input_text": "generate docstring for atob", "output_text": "\n/**\n * Decodes a base64 encoded string.\n * @param {string} encodedString - The base64 string to decode\n * @returns {string} The decoded string\n */\n"}
{"input_text": "generate docstring for btoa", "output_text": "\n/**\n * Encodes a string in base64.\n * @param {string} string - The string to encode\n * @returns {string} The base64 encoded string\n */\n"}
{"input_text": "generate docstring for Object", "output_text": "\n/**\n * The Object constructor creates an object wrapper.\n * @param {*} value - The value to wrap (optional)\n * @returns {Object} The new Object\n */\n"}
{"input_text": "generate docstring for Array", "output_text": "\n/**\n * The Array constructor creates an array.\n * @param {*} elements - The array elements (optional)\n * @returns {Array} The new Array\n */\n"}
{"input_text": "generate docstring for Number", "output_text": "\n/**\n * The Number constructor converts an object to a number.\n * @param {*} value - The value to convert\n * @returns {number} The number \n */\n"}
{"input_text": "generate docstring for Boolean", "output_text": "\n/**\n * The Boolean constructor converts an object to a boolean value.\n * @param {*} value - The value to convert\n * @returns {boolean} The boolean value\n */\n"}
{"input_text": "generate docstring for String", "output_text": "\n/**\n * The String constructor converts an object to a string.\n * @param {*} value - The value to convert\n * @returns {string} The string \n */\n"}
{"input_text": "generate docstring for RegExp", "output_text": "\n/**\n * The RegExp constructor creates a regular expression object.\n * @param {string} pattern - The regex pattern  \n * @param {string} flags - The regex flags\n * @returns {RegExp} The RegExp object\n */\n"}
{"input_text": "generate docstring for Error", "output_text": "\n/**\n * The Error constructor creates an error object.\n * @param {string} message - The error message\n * @returns {Error} The Error object\n */\n"}
{"input_text": "generate docstring for TypeError", "output_text": "\n/**\n * Creates a type error.\n * @param {string} message - The error message\n * @returns {TypeError} The TypeError object\n */\n"}
{"input_text": "generate docstring for RangeError", "output_text": "\n/**\n * Creates a range error.\n * @param {string} message - The error message\n * @returns {RangeError} The RangeError object\n */\n"}
{"input_text": "generate docstring for SyntaxError", "output_text": "\n/**\n * Creates a syntax error.\n * @param {string} message - The error message\n * @returns {SyntaxError} The SyntaxError object\n */\n"}
{"input_text": "generate docstring for ReferenceError", "output_text": "\n/**\n * Creates a reference error.\n * @param {string} message - The error message\n * @returns {ReferenceError} The ReferenceError object  \n */\n"}
{"input_text": "generate docstring for URIError", "output_text": "\n/**\n * Creates a URI error.\n * @param {string} message - The error message\n * @returns {URIError} The URIError object\n */\n"}
{"input_text": "generate docstring for\n  function linearSearch(arr, x) {\n    for (let i = 0; i < arr.length; i++) {\n      if (arr[i] === x) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  ", "output_text": "\n/**\n * Performs a linear search on an array to find the index of a specified element.\n * @param {number[]} arr - The array to search within.\n * @param {number} x - The element to search for.\n * @returns {number} The index of the element in the array or -1 if not found.\n */\n"}
{"input_text": "generate docstring for\n  function binarySearch(arr, x) {\n    let start = 0;\n    let end = arr.length - 1;\n    while (start <= end) {\n      let mid = Math.floor((start + end) / 2);\n      if (arr[mid] === x) {\n        return mid;\n      }\n      if (arr[mid] < x) {\n        start = mid + 1;\n      } else {\n        end = mid - 1;  \n      }\n    }\n    return -1;\n  }\n  ", "output_text": "\n/**\n * Performs a binary search on a sorted array to find the index of a specified element.\n * @param {number[]} arr - The sorted array to search within.\n * @param {number} x - The element to search for.\n * @returns {number} The index of the element in the array or -1 if not found.\n */\n"}
{"input_text": "generate docstring for\n  function selectionSort(arr) {\n    for (let i = 0; i < arr.length; i++) {\n      let minIdx = i;\n      for (let j = i + 1; j < arr.length; j++) {\n        if (arr[j] < arr[minIdx]) {\n          minIdx = j;\n        }\n      }\n      [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];\n    }\n    return arr;\n  }\n  ", "output_text": "\n/**\n * Sorts an array using the selection sort algorithm.\n * @param {number[]} arr - The array to be sorted.\n * @returns {number[]} The sorted array.\n */\n"}
{"input_text": "generate docstring for\n  function insertionSort(arr) {\n    for (let i = 1; i < arr.length; i++) {\n      let current = arr[i];\n      let j = i - 1;\n      while (j >= 0 && arr[j] > current) {\n        arr[j + 1] = arr[j];\n        j--;\n      }\n      arr[j + 1] = current;\n    }\n    return arr;\n  }\n  ", "output_text": "\n/**\n * Sorts an array using the insertion sort algorithm.\n * @param {number[]} arr - The array to be sorted.\n * @returns {number[]} The sorted array.\n */\n"}
{"input_text": "generate docstring for\n  function mergeSort(arr) {\n    if (arr.length < 2) return arr;\n    let mid = Math.floor(arr.length / 2);\n    let left = mergeSort(arr.slice(0, mid));\n    let right = mergeSort(arr.slice(mid));\n    return merge(left, right);\n  }\n  \n  function merge(left, right) {\n    let result = [];\n    while (left.length && right.length) {\n      if (left[0] < right[0]) {\n        result.push(left.shift());\n      } else {\n        result.push(right.shift());\n      }\n    }\n    return [...result, ...left, ...right];\n  }\n  ", "output_text": "\n/**\n * Sorts an array using the merge sort algorithm.\n * @param {number[]} arr - The array to be sorted.\n * @returns {number[]} The sorted array.\n */\n\n/**\n * Merges two sorted arrays into one sorted array.\n * @param {number[]} left - The left sorted array.\n * @param {number[]} right - The right sorted array.\n * @returns {number[]} The merged sorted array.\n */\n"}
{"input_text": "generate docstring for\n  function quickSort(arr) {\n    if (arr.length < 2) return arr;\n    let pivot = arr[0];\n    let left = [];\n    let right = [];\n    for (let i = 1; i < arr.length; i++) {\n      if (arr[i] < pivot) left.push(arr[i]);\n      else right.push(arr[i]);\n    }\n    return [...quickSort(left), pivot, ...quickSort(right)];\n  }\n  ", "output_text": "\n/**\n * Sorts an array using the quick sort algorithm.\n * @param {number[]} arr - The array to be sorted.\n * @returns {number[]} The sorted array.\n */\n"}
{"input_text": "generate docstring for\n  function breadthFirstSearch(graph, start) {\n    let queue = [start];\n    let visited = new Set();\n    visited.add(start);\n    \n    while (queue.length > 0) {\n      let current = queue.shift();\n      console.log(current);\n      for (let neighbor of graph[current]) {\n        if (!visited.has(neighbor)) {\n          visited.add(neighbor);\n          queue.push(neighbor);\n        }\n      }\n    }\n  }\n  ", "output_text": "\n/**\n * Traverses a graph using the Breadth First Search algorithm.\n * @param {Object} graph - The graph represented as an adjacency list.\n * @param {string|number} start - The starting node.\n */\n"}
{"input_text": "generate docstring for\n  function depthFirstSearch(graph, start) {\n    let stack = [start];\n    let visited = new Set();\n    visited.add(start);\n    \n    while (stack.length > 0) {\n      let current = stack.pop();\n      console.log(current);\n      for (let neighbor of graph[current]) {\n        if (!visited.has(neighbor)) {\n          visited.add(neighbor);\n          stack.push(neighbor);\n        }\n      }\n    }\n  }\n  ", "output_text": "\n/**\n * Traverses a graph using the Depth First Search algorithm.\n * @param {Object} graph - The graph represented as an adjacency list.\n * @param {string|number} start - The starting node.\n */\n"}
{"input_text": "Write a docstring for a function in javascript that takes in two numbers as parameters and returns their sum.", "output_text": "/**\n * Adds two numbers.\n * @param {number} num1 - The first number.\n * @param {number} num2 - The second number.\n * @returns {number} The sum of the two numbers.\n */"}
{"input_text": "Write a docstring for a function in javascript that takes in an array of numbers as a parameter and returns the average of those numbers.", "output_text": "/**\n * Calculates the average of an array of numbers.\n * @param {number[]} numbers - Array of numbers.\n * @returns {number} The average of the numbers.\n */"}
{"input_text": "Write a docstring for a function in javascript that takes in a string as a parameter and returns the number of vowels in that string.", "output_text": "/**\n * Counts the number of vowels in a string.\n * @param {string} str - The input string.\n * @returns {number} The number of vowels in the string.\n */"}
{"input_text": "Write a docstring for a function in javascript that takes in an array of strings as a parameter and returns a new array with only the strings that have a length greater than 5.", "output_text": "/**\n * Filters an array of strings to only include those longer than 5 characters.\n * @param {string[]} strings - Array of strings.\n * @returns {string[]} Array of strings longer than 5 characters.\n */"}
{"input_text": "Write a docstring for a function  in javascript that takes in an object as a parameter and returns an array of its keys.", "output_text": "/**\n * Gets the keys of an object.\n * @param {Object} obj - The input object.\n * @returns {string[]} An array of keys from the object.\n */"}
{"input_text": "Write a docstring for a function in javascript that takes in an array of objects as a parameter and returns a new array with only the objects that have a specific property.", "output_text": "/**\n * Filters an array of objects to only include those with a specific property.\n * @param {Object[]} objects - Array of objects.\n * @param {string} property - Specific property to check for.\n * @returns {Object[]} Array of objects with the specific property.\n */"}
{"input_text": "Write a docstring for a function in javascript that takes in a number as a parameter and returns true if it is a prime number, and false otherwise.", "output_text": "/**\n * Checks if a number is prime.\n * @param {number} num - The input number.\n * @returns {boolean} True if the number is prime, false otherwise.\n */"}
{"input_text": "Write a docstring for a function in javascript that takes in a string as a parameter and returns a new string with the vowels replaced by asterisks (*).", "output_text": "/**\n * Replaces vowels in a string with asterisks.\n * @param {string} str - The input string.\n * @returns {string} The string with vowels replaced by asterisks.\n */"}
{"input_text": "Write a docstring for a function in javascript that takes in an array of numbers as a parameter and returns the largest number in the array.", "output_text": "/**\n * Finds the largest number in an array.\n * @param {number[]} numbers - Array of numbers.\n * @returns {number} The largest number in the array.\n */"}
{"input_text": "Write a docstring for a C++ function that takes in two integers as parameters and returns their sum.", "output_text": "/**\n * Calculate the sum of two integers.\n *\n * @param num1 The first integer.\n * @param num2 The second integer.\n * @return The sum of `num1` and `num2`.\n */ \nint sum(int num1, int num2) {\n    return num1 + num2;\n}"}
{"input_text": "Write a docstring for a C++ function that takes in a string as a parameter and returns the length of the string.", "output_text": "/**\n * Calculate the length of a string.\n *\n * @param str The input string.\n * @return The length of `str`.\n */ \nint stringLength(const std::string& str) {\n    return str.length();\n}"}
{"input_text": "Write a docstring for a C++ function that takes in an array of integers and returns the maximum value in the array.", "output_text": "/**\n * Find the maximum value in an array of integers.\n *\n * @param arr The input array.\n * @param size The size of the array.\n * @return The maximum value in `arr`.\n */ \nint findMax(const int* arr, int size) {\n    int max = arr[0];\n    for (int i = 1; i < size; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n    return max;\n}"}
{"input_text": "Write a docstring for a C++ function that takes in a vector of strings and returns a new vector containing only the strings that start with a vowel.", "output_text": "/**\n * Filter a vector of strings to include only the strings that start with a vowel.\n *\n * @param strings The input vector of strings.\n * @return A new vector containing only the strings from `strings` that start with a vowel.\n */ \nstd::vector<std::string> filterVowelStrings(const std::vector<std::string>& strings) {\n    std::vector<std::string> result;\n    for (const std::string& str : strings) {\n        char firstChar = std::tolower(str[0]);\n        if (firstChar == 'a' || firstChar == 'e' || firstChar == 'i' || firstChar == 'o' || firstChar == 'u') {\n            result.push_back(str);\n        }\n    }\n    return result;\n}"}
{"input_text": "Write a docstring for a C++ function that takes in a vector of integers and returns the sum of all the even numbers in the vector.", "output_text": "/**\n * Calculate the sum of all the even numbers in a vector of integers.\n *\n * @param numbers The input vector of integers.\n * @return The sum of all the even numbers in `numbers`.\n */ \nint sumEvenNumbers(const std::vector<int>& numbers) {\n    int sum = 0;\n    for (int num : numbers) {\n        if (num % 2 == 0) {\n            sum += num;\n        }\n    }\n    return sum;\n}"}
{"input_text": "Write a docstring for a C++ function that takes in a string and a character, and returns the number of occurrences of the character in the string.", "output_text": "/**\n * Count the number of occurrences of a character in a string.\n *\n * @param str The input string.\n * @param ch The character to count.\n * @return The number of occurrences of `ch` in `str`.\n */ \nint countOccurrences(const std::string& str, char ch) {\n    int count = 0;\n    for (char c : str) {\n        if (c == ch) {\n            count++;\n        }\n    }\n    return count;\n}"}
{"input_text": "Write a docstring for a C++ function that takes in a vector of integers and returns a new vector containing only the prime numbers from the input vector.", "output_text": "/**\n * Filter a vector of integers to include only the prime numbers.\n *\n * @param numbers The input vector of integers.\n * @return A new vector containing only the prime numbers from `numbers`.\n */ \nstd::vector<int> filterPrimeNumbers(const std::vector<int>& numbers) {\n    std::vector<int> primes;\n    for (int num : numbers) {\n        bool isPrime = true;\n        if (num <= 1) {\n            isPrime = false;\n        } else {\n            for (int i = 2; i <= num / 2; i++) {\n                if (num % i == 0) {\n                    isPrime = false;\n                    break;\n                }\n            }\n        }\n        if (isPrime) {\n            primes.push_back(num);\n        }\n    }\n    return primes;\n}"}
{"input_text": "Write a docstring for a C++ function that takes in a string and returns a new string with all the vowels replaced by asterisks (*).", "output_text": "/**\n * Replace all the vowels in a string with asterisks.\n *\n * @param str The input string.\n * @return A new string with all the vowels replaced by asterisks.\n */ \nstd::string replaceVowelsWithAsterisks(const std::string& str) {\n    std::string result = str;\n    for (char& c : result) {\n        if (std::tolower(c) == 'a' || std::tolower(c) == 'e' || std::tolower(c) == 'i' || std::tolower(c) == 'o' || std::tolower(c) == 'u') {\n            c = '*';\n        }\n    }\n    return result;\n}"}
{"input_text": "Write a docstring for a C++ function that takes in a vector of strings and returns the concatenation of all the strings in the vector.", "output_text": "/**\n * Concatenate all the strings in a vector into a single string.\n *\n * @param strings The input vector of strings.\n * @return The concatenation of all the strings in `strings`.\n */ \nstd::string concatenateStrings(const std::vector<std::string>& strings) {\n    std::string result;\n    for (const std::string& str : strings) {\n        result += str;\n    }\n    return result;\n}"}
{"input_text": "docstring for a function that takes in a list of integers and returns the sum of all the even numbers in the list.", "output_text": "/**\n * Calculate the sum of all even numbers in a list.\n *\n * @param nums List of integers.\n * @return Sum of all even numbers in the list.\n */"}
{"input_text": "docstring for a function that takes in a string and returns the number of vowels in the string.", "output_text": "/**\n * Count the number of vowels in a given string.\n *\n * @param str Input string.\n * @return Number of vowels in the string.\n */"}
{"input_text": "docstring for a function that takes in a list of strings and returns a new list with only the strings that have more than 5 characters.", "output_text": "/**\n * Filter a list of strings to include only strings with more than 5 characters.\n *\n * @param strings List of strings.\n * @return New list with only strings that have more than 5 characters.\n */"}
{"input_text": "docstring for a function that takes in a list of numbers and returns the average of all the numbers in the list.", "output_text": "/**\n * Calculate the average of a list of numbers.\n *\n * @param nums List of numbers.\n * @return Average of all the numbers in the list.\n */"}
{"input_text": "docstring for a function that takes in a string and returns a new string with all the vowels removed.", "output_text": "/**\n * Remove all vowels from a given string.\n *\n * @param str Input string.\n * @return New string with all vowels removed.\n */"}
{"input_text": "docstring for a function that takes in a list of strings and returns a new list with only the strings that start with a vowel.", "output_text": "/**\n * Filter a list of strings to include only strings that start with a vowel.\n *\n * @param strings List of strings.\n * @return New list with only strings that start with a vowel.\n */"}
{"input_text": "docstring for a function that takes in a list of numbers and returns the maximum number in the list.", "output_text": "/**\n * Find the maximum number in a list of numbers.\n *\n * @param nums List of numbers.\n * @return Maximum number in the list.\n */"}
{"input_text": "docstring for a function that takes in a string and returns the reverse of the string.", "output_text": "/**\n * Reverse a given string.\n *\n * @param str Input string.\n * @return Reverse of the input string.\n */"}
{"input_text": "docstring for a function that takes in a list of strings and returns a new list with only the strings that contain the letter 'a'.", "output_text": "/**\n * Filter a list of strings to include only strings that contain the letter 'a'.\n *\n * @param strings List of strings.\n * @return New list with only strings that contain the letter 'a'.\n */"}
{"input_text": "Write a docstring for a function that takes in a list of integers and returns the sum of all the odd numbers in the list divided by 2.", "output_text": "/**\n * Calculate the sum of all odd numbers in a list divided by 2.\n *\n * @param nums List of integers.\n * @return Sum of all odd numbers in the list divided by 2.\n \n */"}
{"input_text": "Write a docstring for a function that takes in a string and returns the number of vowels in the string.", "output_text": "/**\n * Count the number of vowels in a string.\n *\n * @param str Input string.\n * @return Number of vowels in the string.\n * @example\n * count_vowels(\"hello\") => 2\n * count_vowels(\"world\") => 1\n * count_vowels(\"aeiou\") => 5\n */"}
{"input_text": "Write a docstring for a function that takes in a list of strings and returns a new list with only the strings that have more than 5 characters.", "output_text": "/**\n * Filter a list of strings to include only strings with more than 5 characters.\n *\n * @param strings List of strings.\n * @return New list with only strings that have more than 5 characters.\n * @example\n * filter_long_strings([\"hello\", \"world\", \"python\", \"programming\"]) => [\"python\", \"programming\"]\n * filter_long_strings([\"a\", \"b\", \"c\", \"d\", \"e\"]) => []\n * filter_long_strings([\"apple\", \"banana\", \"cherry\", \"date\"]) => [\"banana\", \"cherry\"]\n */"}
{"input_text": "Write a docstring for a function that takes in a list of numbers and returns the product of all the numbers in the list.", "output_text": "/**\n * Calculate the product of all numbers in a list.\n *\n * @param nums List of numbers.\n * @return Product of all numbers in the list.\n * @example\n * calculate_product([1, 2, 3, 4, 5]) => 120\n * calculate_product([2, 4, 6, 8, 10]) => 3840\n * calculate_product([0, 1, 2, 3, 4]) => 0\n */"}
{"input_text": "Write a docstring for a function that takes in a string and returns a new string with all the vowels removed.", "output_text": "/**\n * Remove all vowels from a string.\n *\n * @param str Input string.\n * @return New string with all vowels removed.\n * @example\n * remove_vowels(\"hello\") => \"hll\"\n * remove_vowels(\"world\") => \"wrld\"\n * remove_vowels(\"aeiou\") => \"\"\n */"}
{"input_text": "Write a docstring for a function that takes in a list of strings and returns a new list with only the strings that start with a vowel.", "output_text": "/**\n * Filter a list of strings to include only strings that start with a vowel.\n *\n * @param strings List of strings.\n * @return New list with only strings that start with a vowel.\n * @example\n * filter_strings_starting_with_vowel([\"apple\", \"banana\", \"cherry\", \"date\"]) => [\"apple\"]\n * filter_strings_starting_with_vowel([\"hello\", \"world\", \"python\", \"programming\"]) => []\n * filter_strings_starting_with_vowel([\"a\", \"b\", \"c\", \"d\", \"e\"]) => [\"a\"]\n */"}
{"input_text": "Write a docstring for a function that takes in a list of numbers and returns the average of all the numbers in the list.", "output_text": "/**\n * Calculate the average of all numbers in a list.\n *\n * @param nums List of numbers.\n * @return Average of all numbers in the list.\n * @example\n * calculate_average([1, 2, 3, 4, 5]) => 3.0\n * calculate_average([2, 4, 6, 8, 10]) => 6.0\n * calculate_average([0, 1, 2, 3, 4]) => 2.0\n */"}
{"input_text": "Write a docstring for a function that takes in a string and returns the reverse of the string.", "output_text": "/**\n * Reverse a string.\n *\n * @param str Input string.\n * @return Reverse of the input string.\n * @example\n * reverse_string(\"hello\") => \"olleh\"\n * reverse_string(\"world\") => \"dlrow\"\n * reverse_string(\"python\") => \"nohtyp\"\n */"}
{"input_text": "Write a docstring for a function that takes in a list of strings and returns a new list with only the strings that contain the letter 'a'.", "output_text": "/**\n * Filter a list of strings to include only strings that contain the letter 'a'.\n *\n * @param strings List of strings.\n * @return New list with only strings that contain the letter 'a'.\n * @example\n * filter_strings_containing_a([\"apple\", \"banana\", \"cherry\", \"date\"]) => [\"apple\", \"banana\"]\n * filter_strings_containing_a([\"hello\", \"world\", \"python\", \"programming\"]) => [\"banana\", \"programming\"]\n * filter_strings_containing_a([\"a\", \"b\", \"c\", \"d\", \"e\"]) => [\"a\"]\n */"}
{"input_text": "Write a docstring for a function that takes in a list of numbers and returns the maximum number in the list.", "output_text": "/**\n * Find the maximum number in a list.\n *\n * @param nums List of numbers.\n * @return Maximum number in the list.\n * @example\n * find_maximum([1, 2, 3, 4, 5]) => 5\n * find_maximum([2, 4, 6, 8, 10]) => 10\n * find_maximum([0, 1, 2, 3, 4]) => 4\n */"}
{"input_text": "Write a docstring for a function that takes in a string and returns the number of words in the string.", "output_text": "/**\n * Count the number of words in a string.\n *\n * @param str Input string.\n * @return Number of words in the string.\n * @example\n * count_words(\"hello world\") => 2\n * count_words(\"python programming language\") => 3\n * count_words(\"a b c d e\") => 5\n */"}
{"input_text": "Write a docstring for a function that takes in a list of numbers and returns the average of all the numbers in the list.", "output_text": "/**\n * Calculate the average of all numbers in a list.\n *\n * @param nums List of numbers.\n * @return Average of all numbers in the list.\n * @example\n * calculate_average([1, 2, 3, 4, 5]) => 3\n * calculate_average([2, 4, 6, 8, 10]) => 6\n * calculate_average([0, 1, 2, 3, 4]) => 2\n */"}
{"input_text": "Write a docstring for a function that takes in a list of strings and returns a new list with only the strings that are palindromes.", "output_text": "/**\n * Filter a list of strings to include only strings that are palindromes.\n *\n * @param strings List of strings.\n * @return New list with only strings that are palindromes.\n * @example\n * filter_palindromes([\"level\", \"radar\", \"python\", \"madam\"]) => [\"level\", \"radar\", \"madam\"]\n * filter_palindromes([\"hello\", \"world\", \"python\", \"programming\"]) => []\n * filter_palindromes([\"a\", \"b\", \"c\", \"d\", \"e\"]) => [\"a\", \"b\", \"c\", \"d\", \"e\"]\n */"}
{"input_text": "Write a docstring for a function that takes in a list of strings and returns a new list with only the strings that have more than 5 characters.", "output_text": "/**\n * Filter a list of strings to include only strings that have more than 5 characters.\n *\n * @param strings List of strings.\n * @return New list with only strings that have more than 5 characters.\n * @example\n * filter_strings_with_more_than_5_characters([\"apple\", \"banana\", \"cherry\", \"date\"]) => [\"banana\", \"cherry\"]\n * filter_strings_with_more_than_5_characters([\"hello\", \"world\", \"python\", \"programming\"]) => [\"programming\"]\n * filter_strings_with_more_than_5_characters([\"a\", \"b\", \"c\", \"d\", \"e\"]) => []\n */"}
{"input_text": "Write a docstring for a function that takes in a list of numbers and returns a new list with only the numbers that are divisible by 3.", "output_text": "/**\n * Filter a list of numbers to include only numbers that are divisible by 3.\n *\n * @param nums List of numbers.\n * @return New list with only numbers that are divisible by 3.\n * @example\n * filter_divisible_by_3([1, 2, 3, 4, 5, 6]) => [3, 6]\n * filter_divisible_by_3([3, 6, 9, 12, 15]) => [3, 6, 9, 12, 15]\n * filter_divisible_by_3([2, 4, 8, 10]) => []\n */"}
{"input_text": "Write a docstring for a function that takes in a list of numbers and returns the sum of all the numbers in the list.", "output_text": "/**\n * Calculate the sum of all numbers in a list.\n *\n * @param nums List of numbers.\n * @return Sum of all numbers in the list.\n * @example\n * calculate_sum([1, 2, 3, 4, 5]) => 15\n * calculate_sum([2, 4, 6, 8, 10]) => 30\n * calculate_sum([0, 1, 2, 3, 4]) => 10\n */"}
{"input_text": "Write a docstring for a function that takes in a list of numbers and returns a new list with only the even numbers from the original list.", "output_text": "/**\n * Filter a list of numbers to include only the even numbers.\n *\n * @param nums List of numbers.\n * @return New list with only the even numbers from the original list.\n * @example\n * filter_even_numbers([1, 2, 3, 4, 5]) => [2, 4]\n * filter_even_numbers([2, 4, 6, 8, 10]) => [2, 4, 6, 8, 10]\n * filter_even_numbers([0, 1, 2, 3, 4]) => [0, 2, 4]\n */"}
{"input_text": "Write a docstring for a function that takes in a list of strings and returns a new list with only the strings that are all uppercase.", "output_text": "/**\n * Filter a list of strings to include only the strings that are all uppercase.\n *\n * @param strings List of strings.\n * @return New list with only the strings that are all uppercase.\n * @example\n * filter_uppercase_strings([\"HELLO\", \"WORLD\", \"PYTHON\", \"PROGRAMMING\"]) => [\"HELLO\", \"WORLD\", \"PYTHON\", \"PROGRAMMING\"]\n * filter_uppercase_strings([\"hello\", \"world\", \"python\", \"programming\"]) => []\n * filter_uppercase_strings([\"A\", \"B\", \"C\", \"D\", \"E\"]) => [\"A\", \"B\", \"C\", \"D\", \"E\"]\n */"}
{"input_text": "Write a python function named `sum_numbers` that takes in a list of numbers as input and returns the sum of all the numbers in the list.", "output_text": "```\ndef sum_numbers(numbers):\n    \"\"\"\n    Returns the sum of all the numbers in the given list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The sum of all the numbers in the list.\n    \"\"\"\n    return sum(numbers)\n```"}
{"input_text": "Write a python function named `calculate_average` that takes in a list of numbers as input and returns the average of all the numbers in the list.", "output_text": "```\ndef calculate_average(numbers):\n    \"\"\"\n    Returns the average of all the numbers in the given list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The average of all the numbers in the list.\n    \"\"\"\n    return sum(numbers) / len(numbers)\n```"}
{"input_text": "Write a python function named `find_maximum` that takes in a list of numbers as input and returns the maximum number in the list.", "output_text": "```\ndef find_maximum(numbers):\n    \"\"\"\n    Returns the maximum number in the given list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The maximum number in the list.\n    \"\"\"\n    return max(numbers)\n```"}
{"input_text": "Write a python function named `sort_list` that takes in a list of numbers as input and returns a new list with the numbers sorted in ascending order.", "output_text": "```\ndef sort_list(numbers):\n    \"\"\"\n    Returns a new list with the numbers sorted in ascending order.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        A new list with the numbers sorted in ascending order.\n    \"\"\"\n    return sorted(numbers)\n```"}
{"input_text": "Write a python function named `calculate_factorial` that takes in a positive integer as input and returns the factorial of that number.", "output_text": "```\ndef calculate_factorial(n):\n    \"\"\"\n    Returns the factorial of the given positive integer.\n\n    Args:\n        n: A positive integer.\n\n    Returns:\n        The factorial of the given number.\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return n * calculate_factorial(n-1)\n```"}
{"input_text": "Write a python function named `count_vowels` that takes in a string as input and returns the number of vowels (a, e, i, o, u) in the string.", "output_text": "```\ndef count_vowels(string):\n    \"\"\"\n    Returns the number of vowels (a, e, i, o, u) in the given string.\n\n    Args:\n        string: A string.\n\n    Returns:\n        The number of vowels in the string.\n    \"\"\"\n    vowel_count = 0\n    for char in string:\n        if char.lower() in ['a', 'e', 'i', 'o', 'u']:\n            vowel_count += 1\n    return vowel_count\n```"}
{"input_text": "Write a python function named `reverse_string` that takes in a string as input and returns a new string with the characters in reverse order.", "output_text": "```\ndef reverse_string(string):\n    \"\"\"\n    Returns a new string with the characters in reverse order.\n\n    Args:\n        string: A string.\n\n    Returns:\n        A new string with the characters in reverse order.\n    \"\"\"\n    return string[::-1]\n```"}
{"input_text": "Write a python function named `remove_duplicates` that takes in a list of numbers as input and returns a new list with duplicate elements removed.", "output_text": "```\ndef remove_duplicates(numbers):\n    \"\"\"\n    Returns a new list with duplicate elements removed.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        A new list with duplicate elements removed.\n    \"\"\"\n    return list(set(numbers))\n```"}
{"input_text": "Write a python function named `capitalize_string` that takes in a string as input and returns a new string with the first letter of each word capitalized.", "output_text": "```\ndef capitalize_string(string):\n    \"\"\"\n    Returns a new string with the first letter of each word capitalized.\n\n    Args:\n        string: A string.\n\n    Returns:\n        A new string with the first letter of each word capitalized.\n    \"\"\"\n    return ' '.join(word.capitalize() for word in string.split())\n```"}
{"input_text": "Write a python function named `get_common_elements` that takes in two lists as input and returns a new list containing the common elements between the two input lists.", "output_text": "```\ndef get_common_elements(list1, list2):\n    \"\"\"\n    Returns a new list containing the common elements between the two input lists.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n\n    Returns:\n        A new list containing the common elements between the two input lists.\n    \"\"\"\n    return list(set(list1) & set(list2))\n```"}
{"input_text": "Write a python function named `find_prime_numbers` that takes in a positive integer as input and returns a list of all prime numbers up to and including that number.", "output_text": "```\ndef find_prime_numbers(n):\n    \"\"\"\n    Returns a list of all prime numbers up to and including the given positive integer.\n\n    Args:\n        n: A positive integer.\n\n    Returns:\n        A list of all prime numbers up to and including the given number.\n    \"\"\"\n    prime_numbers = []\n    for num in range(2, n+1):\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            prime_numbers.append(num)\n    return prime_numbers\n```"}
{"input_text": "Write a python function named `is_palindrome` that takes in a string as input and returns True if the string is a palindrome (reads the same forwards and backwards), and False otherwise.", "output_text": "```\ndef is_palindrome(string):\n    \"\"\"\n    Returns True if the given string is a palindrome (reads the same forwards and backwards), and False otherwise.\n\n    Args:\n        string: A string.\n\n    Returns:\n        True if the string is a palindrome, False otherwise.\n    \"\"\"\n    reversed_string = string[::-1]\n    return string == reversed_string\n```"}
{"input_text": "Write a python function named `calculate_power` that takes in two numbers as input: a base number and an exponent number. The function should return the result of raising the base number to the power of the exponent number.", "output_text": "```\ndef calculate_power(base, exponent):\n    \"\"\"\n    Returns the result of raising the base number to the power of the exponent number.\n\n    Args:\n        base: The base number.\n        exponent: The exponent number.\n\n    Returns:\n        The result of raising the base number to the power of the exponent number.\n    \"\"\"\n    return base ** exponent\n```"}
{"input_text": "Write a python function named `find_common_elements` that takes in two lists as input and returns a new list containing the common elements between the two input lists.", "output_text": "```\ndef find_common_elements(list1, list2):\n    \"\"\"\n    Returns a new list containing the common elements between the given two lists.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n\n    Returns:\n        A new list containing the common elements between the two input lists.\n    \"\"\"\n    return list(set(list1) & set(list2))\n```"}
{"input_text": "Write a python function named `is_palindrome` that takes in a string as input and returns True if the string is a palindrome, and False otherwise. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward, ignoring spaces, punctuation, and capitalization.", "output_text": "```\ndef is_palindrome(string):\n    \"\"\"\n    Returns True if the given string is a palindrome, and False otherwise.\n\n    Args:\n        string: A string.\n\n    Returns:\n        True if the string is a palindrome, False otherwise.\n    \"\"\"\n    string = string.lower().replace(\" \", \"\").replace(\",\", \"\").replace(\".\", \"\")\n    return string == string[::-1]\n```"}
{"input_text": "Write a python function named `calculate_area` that takes in the length and width of a rectangle as input and returns the area of the rectangle.", "output_text": "```\ndef calculate_area(length, width):\n    \"\"\"\n    Returns the area of a rectangle given its length and width.\n\n    Args:\n        length: The length of the rectangle.\n        width: The width of the rectangle.\n\n    Returns:\n        The area of the rectangle.\n    \"\"\"\n    return length * width\n```"}
{"input_text": "Write a python function named `is_palindrome` that takes in a string as input and returns True if the string is a palindrome, and False otherwise.", "output_text": "```\ndef is_palindrome(string):\n    \"\"\"\n    Returns True if the given string is a palindrome, and False otherwise.\n\n    Args:\n        string: A string.\n\n    Returns:\n        True if the string is a palindrome, False otherwise.\n    \"\"\"\n    reversed_string = string[::-1]\n    if string == reversed_string:\n        return True\n    else:\n        return False\n```"}
{"input_text": "Write a python function named `check_prime` that takes in a number as input and returns True if the number is prime, and False otherwise.", "output_text": "```\ndef check_prime(number):\n    \"\"\"\n    Returns True if the given number is prime, and False otherwise.\n\n    Args:\n        number: An integer.\n\n    Returns:\n        True if the number is prime, False otherwise.\n    \"\"\"\n    if number < 2:\n        return False\n    for i in range(2, int(number ** 0.5) + 1):\n        if number % i == 0:\n            return False\n    return True\n```"}
{"input_text": "Write a function named `calculate_area` that takes in two parameters, `length` and `width`, and returns the area of a rectangle. The area of a rectangle is calculated by multiplying the length and width. In your function, make sure to include a docstring that explains the purpose of the function, its parameters, and its return value. Also, include an example usage of the function in the docstring.", "output_text": "``` def calculate_area(length, width): \"\"\" Calculate the area of a rectangle given its length and width. Args: length (float): The length of the rectangle. width (float): The width of the rectangle. Returns: float: The area of the rectangle. Example: ``` rectangle_length = 5.0 rectangle_width = 3.0 rectangle_area = calculate_area(rectangle_length, rectangle_width) print(rectangle_area) # Output: 15.0 ``` \"\"\" return length * width ```"}
{"input_text": "Write a docstring for a Python function called `linear_regression` that implements the linear regression algorithm. The function should take in two parameters: `X` and `y`, which are the input features and target values, respectively. The function should return the coefficients of the linear regression model. Use the `numpy` library to perform the necessary calculations. For example: ```python import numpy as np def linear_regression(X, y): # Code goes here X = np.array([[1, 2], [3, 4], [5, 6]]) y = np.array([3, 5, 7]) coefficients = linear_regression(X, y) print(coefficients) ```", "output_text": "```\"\"\" Perform linear regression on the given input features and target values. Parameters: - X (numpy.ndarray): Input features, where each row represents a sample and each column represents a feature. - y (numpy.ndarray): Target values. Returns: - coefficients (numpy.ndarray): Coefficients of the linear regression model. Example: >>> import numpy as np >>> X = np.array([[1, 2], [3, 4], [5, 6]]) >>> y = np.array([3, 5, 7]) >>> coefficients = linear_regression(X, y) >>> print(coefficients) [1. 1.] \"\"\" ```"}
